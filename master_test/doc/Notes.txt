pwilshire
june 18, 2020

Following a detailed 3 way demo and more understanding on the role in the ERCOT BRP domain the following changes have been made to the 
system design.

1/ URI/Varname Combination
Original assumption ... all variables are unique has been modified.
The unique identifier is the uri / var name combination.

so a variable called "sel_active_power"
could be present on "sel_735" and "sel_761"
Here are two possible definitions:


            "id": "active_power",
            "name": "Sel 735 Active Power",
            "variation":"Group30Var5",
            "evariation":"Group32Var7",
            "uri":"/metrics/misc/sel_735",
            "signed": true

            "id": "active_power",
            "name": "Sel 761 Active Power",
            "variation":"Group30Var5",
            "evariation":"Group32Var7",
            "uri":"/metrics/misc/sel_761",
            "signed": true

Each of these represents the same value but from two different sites.
The uri allows the variable to be accessed individually.

This also means that , with careful uri naming , the system can provide "flow through" routing where needed.
The uri name can be changed for different uses (outstation or master) of the same varible .

Consider telemtry back from a site haaded directly to the control master (ERCOT)

Site 735  outstation
<default uri>
gets a pub 
   /interfaces/site_735/active_power 2345

                Fleet Manager Site 735 Master
                < uri /components/site_735 active_power>
                issues a pub 
                /components/site_735/active_power 2345

                                     Fleet Manager ERCOT outstation renames the var to 
                                         sel_735_active_power
                                     <uri /components/site_735]
                                     sends it to ERCOT master


                                             ERCOT Master
                                                    recieves value in analogs at the designated point index 



default uri

If no uri is specified for an individual variable it will assume the default url.


for master 
  /components/<system_id>
for outstation
  /interfaces/<system_id>

if the base_uri is defined this will be used.
NOTE the base_uri Must have a leading '/'

<base_url>/<system_id>

These values can be defined in the system set up of the config file.
    "system": {
        "ip_address2": "127.0.0.1",
        "port2": 502,
        "id": "fm_master",
        "ip_address": "127.0.0.1",
        "port": 12502,
        "local_uri": "/fm_master_local",
        "base_uri": "/comp/master",
        "frequency":1000
    },


local uri

Normally the outstation will only respond to "pubs" (and not "posts", yet)

The outstation does contain a copy of the full variable database. 

The local_uri is used to permit access to that data
"system": {
        "id": "hybridos",
        "id": "hybridos",
        "ip_address": "127.0.0.1",
        "port": 12502,
        "local_uri":"/local/outstation"
    },

$ fims_send -m set -u /interfaces/hybridos/ess_average_soc 3344 -r /me
Receive Timeout.

$ fims_send -m get -u /interfaces/hybridos/ess_average_soc  -r /me
Receive Timeout.

$ fims_send -m set -u /local/outstation/interfaces/hybridos/ess_average_soc 3344 -r /me
{"ess_average_soc":3344}

$ fims_send -m get -u /local/outstation/interfaces/hybridos/ess_average_soc  -r /me
{"ess_average_soc":3344}

The outstation will set its local variables frpm a pub uri 

$ fims_send -m get -u /local/outstation/interfaces/hybridos/ess_average_soc  -r /me
{"ess_average_soc":3344}

$ fims_send -m pub -u /interfaces/hybridos/ess_average_soc 10023

$ fims_send -m get -u /local/outstation/interfaces/hybridos/ess_average_soc  -r /me
{"ess_average_soc":10023}



The local_uri option is also available on the master but there is no similar restriction on the get and set uris on the master



Variables

Variables are defined in the config file.

There are two major classes of variables

The Master will receive data from the outstation as one of two data types.
Analog and Binary.
This outstation listens to pubs on the registered uris.
It also checks that the data items in the pubs have been defined in the config file.
If a match is found 

June 1, 2020

Linkback
A link back means update one of your local variables when the remote system sends you a value o a different variable.
For example a linkback setup like this for 
     "AnOPInt32": [
             {
                "id": "voltageSP",
                "offset": 3,
                "name": "voltageSP",
                "unit": "MW",
                "signed": true,
                "uri": "/site/uri",
                "linkback":"site_voltageSP" << causes voltageSP to be updated in the master from a incoming value for site_voltageSP
            } (edited) 



A linkback test would look like this....

set VoltageSPto 550 on master


fims_send -m set -u /components/dnp3_master/voltageSP 550 -r /me
    #expect {"voltageSP":550}



this will send the value to the outstation resulting in a 
   set /site/uri/voltageSP 550 

on the outstation.

outstation will respond with a modified value ( for example 450)

       pub /outstation/site_voltageSP 450

fims_send -m pub -u /components/dnp3_outstation/site_voltageSP 450 -r /me
 #expect {"site_voltageSP":450}

the linkback option causes the value of the incoming site_voltageSP variable on the master (from the outstation) 
to also set the value of voltageSP on the master.


This can be verified using a check of VoltageSP on the master

fims_send -m get -u /components/dnp3_master/voltageSP -r /me

#expect {"voltageSP":450}


#But Note if the master does a "set" to "voltageSP" on the outstation 
   then also does a outstation scan before the /site/outstation updates the value of site_voltageSP
   we will ge the old value of site_voltageSP when getting the value of voltageSP on the master    
   this is an out of sync situation.

here is the out of syc sequence.
Tell the master to set the new voltageSP value.


fims_send -m set -u /components/dnp3_master/voltageSP 550 -r /me

master runs scan of outstation before the outstation system reacts to the new request to set voltageSP from the master.
the query to the master gets old value of site_voltageSP (say 400)

fims_send -m get -u /components/dnp3_master/voltageSP -r /me
{"voltageSP 400"}

Eventually the outstation recieves the new value from master and updates the site 
fims_send -m set -u /site/voltageSP  550

This results in an updated value of site_voltageSP being pub'd on the outstation.

fims_send -m pub -u /site/site_voltageSP 450

The outstation receives the new value and sends an update to the master.

once the master receives the message from the outstation it will update thne local voltageSP value on the master

# now this works
fims_send -m get -u /components/dnp3_master/voltageSP -r /me
{"voltageSP 450"}




PRINT options

At the fims input command is parsed the value field can be a simple '{"varname":value} or have a value subobject '{"varname":{"value":value}}'
A flag is created for each object in the parsed bosy which will have a bit set PRINT_VALUE to remember the presence of the "value" object.
This allows the output reply to return the value in the simple form or as the value subobject.
This flag is also used to indicate if the value being processed was a readback variable.
For example a write on the outstation was sent to "voltageSP" the outstation used the readback variable "_voltageSP" but the response to the "set" command should have the original name plus the ew value.


CROB readback
In the Modbus world CROBS are like coils. Crobs, however, have many more options. 
Modbus treats coils as hving simple on/off values.
For now the readback variable will be a 16 bit analog reflecting the desired CROB value.
This will keep the original CROB desigation. The translaion to the Mobus equivalent True/False may have to be defined in the System Setup.


pwilshire
May 31, 2020

More on the output readback system.
I have distilled this requirement as follows.
Normally an output from the master to the outstation is write ( and due to local DB read) in the master and read (but no write) on the outstation.
The readback function is intended to provide a way for the system on the outstation to respond with an actual value in reply to the setpoint. request from the master.
The setup of this requirement is simply addressed using a "readback" keyword in the config file.
 For example:
    "AnOPInt32": [

          {
                "id": "voltageSP",
                "offset": 3,
                "name": "voltageSP",
                "unit": "MW",
                "signed": true,
                "uri": "/home/mystuff/uri",
                "readback":"analog"
            }

The readback keyword triggers the creation of a readback var in both master and outstation local databases.
the name has a "_" prepended.
Setting a value on the master for voltageSP will send the setpoint to the outstation.

fims_send -m set -r /me -u /components/dnp3_master/voltageSP '{"value":3444}'

The master and outstation can read the voltageSP value.

fims_send -m get -r /me -u /components/dnp3_outstation/voltageSP
{"voltageSP":3444}

Also read the value from the Master ( local DB)
fims_send -m get -r /me -u /components/dnp3_master/voltageSP
{"voltageSP":3444}

With the new readback option, the outstation can now write a value to the same variable

 fims_send -m set -r /me -u /components/dnp3_outstation/voltageSP '{"value":6444}'

This will cause the value "6444" to be returned to the master as a new variable "_voltageSP"

The original value can be read from both master and outstation as "voltageSP" and the readback value can be discovered by reading the value "_voltageSP"
This outstation behavior is now in the branch.

If required, the master can be modified so that a read of the local value from the original name "voltageSP" will return the readback value.
Both the  outstation  and master config files will need to have the readback keys in their  config files.

( We need this to maintain the variable / point index tracking).
There are two options for readback keys "analog" or "binary" ( these may be designated automatically).

The variation for the readback key data item will be worked out automatically.
We have a number of different output types AnInt16, AnIt32, AnF32, AnF64 and CROB.
Note I have not worked out what to do about the CROB system yet. I think we need to send simply "on" or "off" commands to it . These could be simply mapped to LATCH_ON and LATCH_OFF.
I'll review the Modbus system and come up with a plan.




pwilshire
May 29, 2020

problem ... we stup an output from the master station 
it gets delivered to the outstation as an ANINT16, AnInt32, AnF32 or a crob.
There seem to be no other types.

Now the outstation will attemp to set a setpoint at the outstation . A set FIMS message will be sent to cause the periperal to be given a target.
The peripheral will then provide feedack on the actual value in use.
master sends value .. outstation set target (set <uri> <value>)
This means that a value must have been declared as a master output variable AnInt32 or something else.
The requirement  is for selected variable to have an  feedback path.

THe outstation will respond to a pub function but will normally reject variables that are designated as master variables.
an attempt to set or pub those on an outstation are normally rejected.
However if an outstation output var is desired to be automatically linked to a status variable the result of the set should be returned to the master.

Follow this sequence
master set to a holding register.
master sends this to outstation,  outstation issues a set to the outstation process via the uri associated with the variable.
The outstation process issues a Pub to the same uri/var with a response value.
Te outstation sees that such a pub has to be returned to the master and sets a feeedback  var.
   1+++> flag the var to return a status.
The outstation will return the value in the feedback var 

Luckily both master ad outstation use the same config files.
A var tagged for a feedback is simply marked as such in its data def and now both master and outstation can map it correctly.
"readback":"analog"  will do the trick.
Having done this both master and outstation will be able to track the var.



pwilshire
May 15, 2020

Discussion Document  on the whole Fleet Manager/DNP3 system.

The Fleet Manager (FM) unit has one customer facing DNP3 Outstation and one or more site facing DNP3 FM Site Master stations.
Each Site will have a DNP3 Site Outstation connecting to a Modbus Client.

Customer      |  Fleet Manager                                   |   |  Sites
DNP3 Master<---->FM DNP3 Outstation                              |   |
              |           |                                      |   |
              |           --------------->FM Site1 DNP3 Master<---------->Site1 DNP3 Outstation    Site1 Modbus Client
              |           |                                      |   |
              |           --------------->FM Site2 DNP3 Master<---------->Site2 DNP3 Outstation    Site2 Modbus Client
              |           ~
              |           ~
              |           |                                      |   |
              |           --------------->FM SiteN DNP3 Master<---------->SiteN DNP3 Outstation    SiteN Modbus Client


The FM DNP3 Outstation will receive output commands and query requests from the Customer DNP3 Master.
The Customer commands will be passed on to one of the FM Site DNP3 Masters based on the output destination.
The FM DNP3 Outstation will receive PUBS from each of the FM Site DNP3 Master stations connected to the site units.
The FM DNP3 Outstation will hold registers containing the values of the system variables designated as inputs.

Question: does the FM DNP3 outstation need to retain the state of the Output commands. 
        if so we can use the DNP3 status variables for these.
        The status variables can be set in  the Site DNP3 Outstations after the Output command has been reeived.
        These variables will be returned to the FM DNP3 Outstation as part of the FM Site Master queries


Each FM Site DNP3 Master will issue queries on its assigned Site DNP3 Outstation.
Ther reults of these queries will be used to update the FM DNP3 Outstation variables,


The modbus FIMS message struture is:

set/get/pub /components/sys.cfg_name [{"name": name, "value":value},....] 
or   
set/get /components/sys.cfg_name/item {"value":value}


The dnp3 scheme is more complex in that a name resolves to :

<type>:index    for outputs and inputs
types being : 
    binary,analog, [counters , strings etc ] for DNP3 Site Outstation INPUTS
and
   AnalogOutputInt16, AnalogOutputInt32,AnalogOutputFloat32,ControlRelayOutputBlock [AnalogOutputDouble64,] for DNP3 Site Outstation OUTPUTS
 
each of these item types uses an index to define the component.

In addition the outstation INPUTS can define a variant to define to format used for the the value messages.

Lets consider an Output command from the Customer DNP3 Master.
We want to set the variable "gen_resource_breaker" on Site 21  to LATCH_OFF
The Customer Database knows this as Site21/gen_resource_breaker, it is of type CROB ( Control Relay Output Block) 
   and its index in the FM DNP3 Outstation CROB array is 32
The Customer Database also reads the status of this output as BinaryStatus offset 12.

This is the suggested config file fragment   

not quite sure of the exact systax yet.

"Sites": {
        "Site21": {
            "outputs" : {
                "CROB" : [
                    {
                        "id": "gen_resource_breaker",
                        "dest": "Site21_modbus/gen_resource_breaker",
                        "status": "Site21_outstation/gen_resource_breaker_status",
                        "offset": 32,
                        "name": "Generation Resource Breaker Control"
                        "initial_value":"LATCH_OFF"
                        "site_offset: 2
                    },
                ] <,>
            }
            "inputs" : {
                "BinaryOutputStatus" : [
                    {
                        "id": "gen_resource_breaker_status",
                        "offset": 12,
                        "name": "Generation Resource Breaker Control Status"
                        "site_offset: 1
                        "variant":"Group10Var2"
                    },
                ] ,
                "Analog" : [
                    {
                        "id": "line_flows_MW",
                        "offset": 4,
                        "name": "line flows MW"
                        "site_offset: 2
                        "variant":"Group30Var1"
                    },
                ] <,>


            }
        }<,>
}


Customer Output

So lets create a dummy DNP3 Master to simulate the customer DNP3 master.
We would congfigure it with the something like the fragment shown above.

Somewhere the sys_config.name of the master is ERCOT_master.
Also we will have two other site names to consider 
FM_outstation
Site21_master
Site21_outstation


The FIMS message to send to this Simulated master would be:
ERCOT_master <== set /components/ERCOT_master/Site21/gen_resource_breaker "LATCH_ON"

This would cause the FM DNP3 Outstation to receive a LATCH_ON command for CROB index 32.
It would look up the designated site from the config file and detect that it needs to direct this command to Site1_master.

FM_outstation ==> set /component/Site21_master/gen_resource_breaker "LATCH_ON"

The FM_Site21_master will send the CROB message to CROB:<2> to the Site1 DNP3 Outstation this system will then relay the command to the Site21 Modbus Client


This Site21 DNP3 outstation will then issue the Modbus fims message due to the  "dest":"Site21_modbus/gen_resource_breaker" field

    set /component/Site21_modbus/gen_resource_breaker "LATCH_ON" ( or whatever the modbus requires as a 'latch_on' value)

The Site21 DNP3 outstation will  also send a fims message to itself due to the "status":"Site21_outstation/gen_resource_breaker_status" field

    set /component/Site21_outstation/gen_resource_breaker_status "LATCH_ON"


Customer inputs
An Example 
Our Customer DNP3 Master wants to know what the current value of 
"line_flows_MW" on Site21 

We'll use the fims command
ERCOT_master <== get /components/ERCOT_master/Site21/line_flows_MW
The ERCOTT_master will issue a query to the FM DNP3_outstation which will respond with the current value in its local storage.

The FM DNP3 Site Masters will each issue queries on their outstations and issue pubs when they receive results.
The pubs will be monitored buy the FM DNP3 outstation and translated into updates to the ERCOTT_master.



The Site DNP3 outstations will listen to the MODBUS_Client pubs and update their values.
This will transfer to the FM DNP3 Master
that will also issue pubs on the current values.

the FM DNP3 Outstation will listen to those pubs and issue updates to its own copies of the variables.


Here is the whole path from Site Modbus Client to FM DNP3 Outstation

Site21 MODBUS Client, 
       pub /comonents/Site21  '[{"name":value},{"name":value}]
Site21 DNP3 outstation translates names to local variable types and offsets.
       issues update commands to its DNP3 local Database 
FM Site21 DNP3  master  queries Site21 DNP3 Outstation and issues a pub when the response is received.
       pub /comonents/Site21_master  '[{"name":value},{"name":value}]

FM DNP3_outstation listens to these pubs and updates the local database with the modified customer offsets.

The Customer DNP3 master will then get the updated values.


How about a demand query ??

I understand that this may be an enhancement. the system may happily depend on scheduled quieries.

This will ripple a query all the way down to the Site Modbus client

Start at the Site DNP3 Outstation.

This is issued with a demand for a list of values (not just a general Class 0 scan) from its FM Site DNP3 Master
This can be simulated using a "get" for a list of variables sent to the FM Site DNP3 Master

The Site DNP3 Outstation will translate this into a Site modbus client "get" request.

The response (via reply to) to the "get" request will be treated the same as a "set" request placed on the Site DNP3 Outstation.
This will result in a number of buffer puts relayed to the FM Site DNP3  Master.

Lets assume that we can modify the "pub" issued by the FM DNP3 Site Master into "sets" headed for the FM DNP3 Outstation
( For example use the indicator for an unsolicitated response)

These "sets" to the FM DNP3 Outstation will result in Buffer pushes to the Customer DNP3 Master


This is a diagram of the transaction:

get /components/ERCOTT_master '["name","name"]'

   master creates a variable list and send request to FM DNP3 Outstation
   since this is not a general class scan FM DNP3 issues "get" fims messages to FM Site DNP3 Masters

   get /components/Sitex_master '["name","name"]'

   FM Sitex DNP3 Master creates and sends a query list to its Site DNP3 outstation

   The site DNP3 outstation notices this is not a general query and sends "get" message to the  Site Modbus Client
   The Site Modbus Client responds
   The Site DNP3 Outstation sets it buffers and sends updates to the FM Site DNP3 Master
   The FM Site DNP3 Master will issue pubs which are received by the FM DNP outstation. 
   This sets its buffers and causes a response to the Customer DNP3 Master.













