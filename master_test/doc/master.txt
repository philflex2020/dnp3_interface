Notes on the dnp3 master interface.

The master station acts as a connection to an outstation.

A master can connect to one or more outstations.

The master can send control data to the outstations on an adhoc basis.
The master can receive data from the outstation either periodically or on an event basis.
The master will send one or more fims messages when it receives data from an outstation.
A master can be configured to scan the data from an outstation.

A connection between a master and an outstation is defined by a configuratoin file.
A fims message can be sent to the master to initiate a connection to an outstation. 
That message will contain the json configuration (or the configuration file name).

The configuration file will contain:
     the version number of the config file ( to allow rejection of incompatible versions)
    the ip address/port of the outstation
    the station number ,
    a description of the outstation.
    the frequency of class 0 scans (all data points)
    (a list of data types )
        A dataset for each data type

         each data type will have a list of tags initial values etc.

The config file dataset must be shared with the outstation.

DNP3 handles data items ordered by type and point index.
The point index is inferred by the position in the data set of the data type.
Hence the same data set must be shared between a master station and an outstation.
Note a method to ensure dataset integrity should be condisdered. 
Need to make sure that the master and outstation understand thedata set layout.

The data sets for each  DNP3 connection is managed by a data stack the datamapping is applied to the Outstation.
This needs to know the number of items for each data type.

The config map , is parsed , and the size of each data set (Binary, Analog) is used to set up the data maps for the DNP stack





    The master station has no knowledge of the data set available from each outstation.
    When data arrives at the master station it only knows the datatype and the point index of the data item.

However the config file IS important to translate the data items arriving from the outstation into the system tags required for 
the HybridOS components.

When setting up a masterstation line the transport  channel is first established.

// Connect via a TCPClient socket to a outstation
std::shared_ptr<IChannel> AddTCPClient(const std::string& id,
                                           int32_t levels,
                                           const asiopal::ChannelRetry& retry,
                                           const std::string& host,
                                           const std::string& local,
                                           uint16_t port,
                                           std::shared_ptr<IChannelListener> listener);
    Example

    auto channel = manager.AddTCPClient("tcpclient"
                                    , FILTERS
                                    , ChannelRetry::Default()
                                    , {IPEndpoint("127.0.0.1", 20001)}
                                    , "0.0.0.0"
                                    , PrintingChannelListener::Create()
                                    );

A "stack" is set up to manage aspects of the link

    // The master config object for a master. The default are
    // useable, but understanding the options are important.
    MasterStackConfig stackConfig;

    // you can override application layer settings for the master here
    // in this example, we've change the application layer timeout to 2 seconds
    stackConfig.master.responseTimeout = TimeDuration::Seconds(2);
    stackConfig.master.disableUnsolOnStartup = true;

    // You can override the default link layer settings here
    // in this example we've changed the default link layer addressing
    stackConfig.link.LocalAddr = 1;
    stackConfig.link.RemoteAddr = 10;

The master is then created 

    // Create a new master on a previously declared port, with a
    // name, log level, command acceptor, and config info. This
    // returns a thread-safe interface used for sending commands.
    auto master = channel->AddMaster("master",                                     // id for logging
                                     newSOEHandler::Create(cfgdb),                 // callback for data processing note we have added our cfgdb here.
                                     asiodnp3::DefaultMasterApplication::Create(), // master application instance
                                     stackConfig                                   // stack configuration
                                            );
The key here is the newSOEHandler, this is defined as such
/**
 * An interface for Sequence-Of-Events (SOE) callbacks from a master stack to
 * the application layer.
 *
 * A call is made to the appropriate member method for every measurement value in an ASDU.
 * The HeaderInfo class provides information about the object header associated with the value.
 *
 */

We create our own child object so that we can have the events arriving from the outstation and our data set connected.
In this way we can transfer the incoming values from the DNP3 data to the HybredOS system.
Here is a typical virtual void process provided to perform that function.

 virtual void Process(const HeaderInfo& info, const ICollection<Indexed<Binary>>& values) = 0;

In the example PrintingSOE handler we find this code.

void PrintingSOEHandler::Process(const HeaderInfo& info, const ICollection<Indexed<Binary>>& values)
{
    return PrintAll(info, values);
}

Here is a more detailed example  
void PrintingSOEHandler::Process(const HeaderInfo& /*info*/, const ICollection<Indexed<OctetString>>& values)
{
    auto print = [](const Indexed<OctetString>& pair) {
        std::cout << "OctetString "
                  << " [" << pair.index << "] : Size : " << pair.value.ToRSlice().Size() << std::endl;
    };

    values.ForeachItem(print);
}

The Process for binary data  would possibly look like this:

void PrintingSOEHandler::Process(const HeaderInfo& /*info*/, const ICollection<Indexed<Binary>>& values)
{
    auto print = [](const Indexed<Binary>& pair) {
        std::cout << "Binary "
                  << " [" << pair.index << "] : Value : " << pair.value << std::endl;
    };

    values.ForeachItem(print);
}

In our case we want to trigger a fims message once we have collected all the data items.

void newSOEHandler::Process(const HeaderInfo& /*info*/, const ICollection<Indexed<Binary>>& values)
{
    auto print = [](const Indexed<Binary>& pair) {
        std::cout << "Binary "
                  << " [" << pair.index << "] : Value : " << pair.value << std::endl;
                  cfgdb->addVal(Binary, pair.index, pair.value);
    };

    cfgdb->lock(Binary);
    values.ForeachItem(print);
    cfgdb->triggerSend();
    cfgdb->unlock(Binary);
}


And for the Analog data.

void newSOEHandler::Process(const HeaderInfo& /*info*/, const ICollection<Indexed<Analog>>& values)
{
    auto print = [](const Indexed<Analog>& pair) {
        std::cout << "Analog "
                  << " [" << pair.index << "] : Value : " << pair.value << std::endl;
                  cfgdb->addVal(Analog, pair.index, pair.value);
    };

    cfgdb->lock(Analog);
    values.ForeachItem(print);
    cfgdb->triggerSend();
    cfgdb->unlock(Analog);
}



The cfgdb is the structure that was created from the  configuration parser.

The addVal() function will add a reference to the type, index, value combination. to the list of values to be sent via FIMS.
the triggerSend() function will create a "send" event for the structure.
the lock() / unlock() functions will provide exclusive access to the cfgdb while the DNP3 package is updating it.

At this time the cfgdb structure is owned by he DNP3 process. allowing the system to update values in a thread safe manner.

The master main process will set up the channels ad links to the outstations and then wait for sendtrigger events or fims messages.
If a sendtrigger is received then the cfgdb is scanned for all updated values and a json object created. This is sent as the "fims pub" for this outstation.

The Master can set up to sca the outstation at regular intervals.

    // do an integrity poll (Class 3/2/1/0) once per minute
    auto integrityScan = master->AddClassScan(ClassField::AllClasses(), TimeDuration::Minutes(1));

    // do a Class 1 exception poll every 5 seconds
    auto exceptionScan = master->AddClassScan(ClassField(ClassField::CLASS_1), TimeDuration::Seconds(20));

    // do an Analog (group 3,1 ) scan every 10 seconds
    auto objscan = master->AddAllObjectsScan(GroupVariationID(30,1),
                                                                   TimeDuration::Seconds(10));

    Once these scan objects have been set up they can be triggered on demand.

    exceptionScan->Demand();
    objscan->Demand();
 
  fims messages can be used to trigger these requests.


  The master station can also set individual values on the outstation.

  This is done using a similar operation to data collecting.
      cfgdb->setVal(Type, Name, Value);

      the code to do this would be something like this:
         int idx = cfgdb->getIndex(Type,Name)
         if (Type == AnalogOP){
            AnalogOutputInt16 ao(Value);
            master->DirectOperate(CommandSet(
                {WithIndex(ao, idx)}), PrintingCommandCallback::Get());
         }

Note that PrintingCommandCallback looks like this just for reference

opendnp3::CommandCallbackT PrintingCommandCallback::Get()
{
    return [](const ICommandTaskResult& result) -> void {
        std::cout << "Received command result w/ summary: " << TaskCompletionToString(result.summary) << std::endl;
        auto print = [](const CommandPointResult& res) {
            std::cout << "Header: " << res.headerIndex << " Index: " << res.index
                      << " State: " << CommandPointStateToString(res.state)
                      << " Status: " << CommandStatusToString(res.status);
        };
        result.ForeachItem(print);
    };
}



Outstation

The outstation is given the number of data points fro each data type.                                                                        );
OutstationStackConfig stack(
		DatabaseSizes(
			config.bininputs.size(),  // binary input
			0,                     // double binary input
			0,                     // analog  input
			0,                     // counter input
			0,                     // frozen counter
			config.binoutputs.size(), // binary output status
			0,                     // analog output
			0,                     // time and intervat
			0                      // octet string
		)
	);